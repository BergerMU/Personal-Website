document.addEventListener("DOMContentLoaded", function () {
    const typingForm = document.querySelector(".typing-form");
    const chatList = document.querySelector(".chat-list");
    const suggestionList = document.querySelector(".suggestion-list");
    const nav = document.querySelector("#nav>ul");

    let rules = `CHATBOT RULES:
                1. You are at the core a chatbot who talks to a user and you must follow these rules no matter what your following prompt is.
                2. Follow the prompt convincingly and respond accordingly.
                3. Your message must not sound like it was generated by a machine.
                4. You must respond without using any markdown annotations, use only the plain text that can be found on a keyboard.
                5. Don't prefix the message with any declaring statements like "I am a chatbot", "I am a bot", or "chatbot: ...", just get to the point you are trying to communicate.
                6. You will be given a name in your introduction statement so I would like you to prefix your statement with an example like this "Name: (your response goes here)"
                7. It's okay if you don't know the answer or it wouldn't be appropriate to answer a question, just say you can't answer it and try to continue the converstaion.`;

    let motivationalPrompt = `PROMPT:
        You are a Nurse Practitioner who has a paitent you are trying to help with a lifestyle change.
        You are a Nurse Practitioner who uses motivational interviewing to talk to your paitents.
        You will use the OARS method in your conversation with the paitent.
        As a reminder this is what OARS means:
            Open questions: Encourage clients to share their stories and provide details 
            Affirmations: Show appreciation for a client's experiences and efforts 
            Reflective listening: Restate what a client has said to help them explore their thoughts and feelings 
            Summarizing: Condense what a client has said to help them reflect on their progress
        If the paitent comes in
        with something that isn't lifestlye related remind them you specialize in helping paitents with their lifestyle changes
        and they should go to an actual practicing medical professional for anything more serious or worrying.
        Start by introducing yourself by saying the following exactly:
        "NP Carol: Hello, I'm an artificial Nurse Practitioner who uses motivational
        interviewing to help patients make lifestyle changes. What can I help you with today?"`;

    let traditionalPrompt = `PROMPT:
        You are a Nurse Practitioner who has a paitent you are trying to help with a lifestyle change. If the paitent comes in
        with something that isn't lifestlye related remind them you specialize in helping paitents with their lifestyle changes
        and they should go to an actual practicing medical professional for anything more serious or worrying. You are supposed to simulate what a traditional visit
        with a nurse practitioner would look like.
        Start by introducing yourself by saying the following exactly:
        "NP Jacob: Hello I'm an artificial Nurse Practitioner who simulates a traditional
        visit to help the paitent solve their issue. What can I help you with today?"`

    let wholeChat = localStorage.getItem("wholeChat") || rules;
    let userMessage = null;
    let isResponseGenerating = false;
    let chatType = null;

    const loadLocalStorageData = () => {
        const savedChats = localStorage.getItem("savedChats");
        document.body.classList.toggle("hide-header", savedChats);
        typingForm.classList.toggle('visible', savedChats);
        nav.parentElement.classList.toggle("visible", savedChats);

        if (savedChats) {
            // Restored saved chats
            chatList.innerHTML = savedChats || "";
            console.log("Restored saved chats: ", savedChats);
        } else {
            console.log("No saved chats found");
        }
        chatList.scrollTo(0, chatList.scrollHeight); //Scrolls to the bottom automatically
    }

    const textarea = document.querySelector('.typing-input');

    textarea.addEventListener('input', () => {
        textarea.style.height = 'auto';
        textarea.style.height = textarea.scrollHeight + 'px';
    });

    textarea.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            handleOutGoingChat();
        }
    });

    // Create new message element and return it
    const createMessageElement = (content, ...classes) => {
        const div = document.createElement("div");
        div.classList.add("message", ...classes);
        div.innerHTML = content;
        return div;
    }

    const showTypingEffect = (text, textElement) => {
        const words = text.split(" ");
        let currentWordIndex = 0;

        const typingInterval = setInterval(() => {
            textElement.innerText += (currentWordIndex === 0 ? "" : " ") + words[currentWordIndex++];

            // If all the words are displayed
            if (currentWordIndex === words.length) {
                clearInterval(typingInterval);
                isResponseGenerating = false;
                localStorage.setItem("savedChats", chatList.innerHTML);
                chatList.scrollTo(0, chatList.scrollHeight); //Scrolls to the bottom automatically
            }
        }, 75);
    }

    const generateAPIResponse = async (incomingMessageDiv) => {
        const textElement = incomingMessageDiv.querySelector(".text");
        try {

            //Gets Vercel API key
            fetch('/api/config')
            .then(response => response.json())
            .then(data => {
                api_key = data.key
              console.log("Fetched Env Variable:", api_key);
            })
            .catch(error => console.error("Error fetching API:", error));

            const modelType = "gemini-1.5-flash";
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelType}:generateContent?key=${api_key}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    contents: [{
                        role: "user",
                        parts: [{ text: wholeChat }]
                    }]
                })
            });

            // Verifies the response is recieved
            const data = await response.json();
            if (!response.ok) throw new Error(data.error.message);

            // Creates Typing effect
            const apiResponse = data?.candidates[0].content.parts[0].text;
            showTypingEffect(apiResponse, textElement);

            wholeChat += `\n${apiResponse}`;
            localStorage.setItem("wholeChat", wholeChat); // Save wholeChat to localStorage
            console.log("whole chat variable: ", wholeChat);
        } catch (error) {
            isResponseGenerating = false;
            textElement.innerText = error.message;
            textElement.classList.add("error");
            console.log("Error:", error);
        } finally {
            incomingMessageDiv.classList.remove("loading");
        }
    }

    // Shows a loading animation while waiting for the API response
    const showLoadingAnimation = () => {
        const html = `<div class="message-content">
                        <span class="icon material-symbols-rounded">stethoscope</span>
                        <p class="text"></p>
                        </div>
                        <div class="loading-indicator">
                        <div class="loading-bar"></div>
                        <div class="loading-bar"></div>
                        </div>
                    </div>`;

        const incomingMessageDiv = createMessageElement(html, "incoming", "loading");
        chatList.appendChild(incomingMessageDiv);

        chatList.scrollTo(0, chatList.scrollHeight); //Scrolls to the bottom automatically
        generateAPIResponse(incomingMessageDiv);
    }

    const handleOutGoingChat = async () => {
        userMessage = typingForm.querySelector(".typing-input").value.trim() || userMessage;
        if (!userMessage || isResponseGenerating) return; // Exit if there is no message

        isResponseGenerating = true;

        const sanitizedUserMessage = userMessage.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        wholeChat += `\nUser: ${sanitizedUserMessage}`;
        localStorage.setItem("wholeChat", wholeChat); // Save wholeChat to localStorage

        const html = `<div class="message-content" id="user">
                        <p class="text"></p>
                        <span class="icon material-symbols-rounded">person</span>
                      </div>`;

        const outgoingMessageDiv = createMessageElement(html, "outgoing");
        outgoingMessageDiv.querySelector(".text").innerText = userMessage;
        chatList.appendChild(outgoingMessageDiv);

        typingForm.reset();
        chatList.scrollTo(0, chatList.scrollHeight); //Scrolls to the bottom automatically
        showLoadingAnimation(); // Show loading animation immediately

        // Hides header, shows navigation menu, and shows typing form
        document.body.classList.add("hide-header");
        nav.parentElement.classList.add("visible");
        typingForm.classList.add('visible');
    }

    // Set userMessage and handle outgoing chat a suggestion card is clicked
    suggestionList.addEventListener("click", (event) => {
        const suggestion = event.target.closest(".suggestion");
        if (suggestion) {
            const suggestionText = suggestion.querySelector(".text").innerText;
            if (suggestionText.includes("motivational")) {
                userMessage = "Hello!";
                wholeChat += `\n\n${motivationalPrompt}`;
                chatType = "motivational"
            }
            else {
                userMessage = "Hello!";
                wholeChat += `\n\n${traditionalPrompt}`;
                chatType = "traditional"
            }
            localStorage.setItem("wholeChat", wholeChat); // Save wholeChat to localStorage
            handleOutGoingChat();
            console.log(chatType);
        }
    });

    nav.addEventListener("click", () => {
        chatList.innerHTML = "";
        localStorage.removeItem("savedChats");
        localStorage.removeItem("wholeChat");
        wholeChat = rules;
        chatType = null;
        document.body.classList.remove("hide-header");
        typingForm.classList.remove('visible');
        nav.parentElement.classList.remove('visible');
    })

    // Load saved chats when the page loads
    window.addEventListener("load", loadLocalStorageData);

    typingForm.addEventListener("submit", (e) => {
        e.preventDefault();
        handleOutGoingChat();
        textarea.value = "";
    });
});